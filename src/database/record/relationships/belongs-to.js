// @ts-check

import BaseRelationship from "./base.js"
import * as inflection from "inflection"

export default class VelociousDatabaseRecordBelongsToRelationship extends BaseRelationship {
  /** @returns {string} */
  getForeignKey() {
    if (!this.foreignKey) {
      const targetModelClass = this.getTargetModelClass()

      if (!targetModelClass) throw new Error("Can't calculate foreign key without a target model class")

      this.foreignKey = `${inflection.underscore(targetModelClass.name)}_id`
    }

    return this.foreignKey
  }

  /** @returns {string | undefined} */
  getInverseOf() {
    if (!this._inverseOf && !this._autoGenerateInverseOfAttempted) {
      this._autoGenerateInverseOfAttempted = true

      // Only make auto-inverse-of if the relationships name matches the target model class's name
      const targetClassSimpleName = `${this.getRelationshipName().substring(0, 1).toUpperCase()}${this.getRelationshipName().substring(1, this.getRelationshipName().length)}`

      const targetModelClass = this.getTargetModelClass()

      if (targetModelClass && targetClassSimpleName == targetModelClass.name) {
        // Only make auto-inverse-of if the expected relationship exist in a has-one or has-many form
        const targetClassRelationshipNames = targetModelClass.getRelationshipNames()
        const autoGeneratedHasOneInverseOfName = `${this.modelClass.name.substring(0, 1).toLowerCase()}${this.modelClass.name.substring(1, this.modelClass.name.length)}`
        const autoGeneratedHasManyInverseOfName = inflection.pluralize(autoGeneratedHasOneInverseOfName)

        if (targetClassRelationshipNames.includes(autoGeneratedHasOneInverseOfName)) {
          this._inverseOf = autoGeneratedHasOneInverseOfName
        } else if (targetClassRelationshipNames.includes(autoGeneratedHasManyInverseOfName)) {
          this._inverseOf = autoGeneratedHasManyInverseOfName
        }
      }
    }

    return this._inverseOf
  }
}
